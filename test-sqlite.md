# Test SQLite 

## Run BranchForcer

### Build SQLite
```
$ ./build-sqlite.sh
```

### Compile sqlite3_flip

```
$ cd sqlite && mkdir flip && cp sqlite3 flip && cd flip 
$ extract-bc sqlite3
$ clang -Xclang -load -Xclang \
  /path/to/viper/tools/splitAfterCall/splitAfterCall.so sqlite3.bc \
  -emit-llvm -c -o sqlite3.bc
$ /path/to/viper/BranchForcer/afl-clang-fast-flip sqlite3.bc -o \
  sqlite3_flip -lpthread -lz -lm -ldl -lreadline
```

### Copy tools

```
$ /path/to/viper/tools/copy_tools.sh /path/to/viper /path/to/viper/sqlite/flip
```

### Flip

Prepare a corpus to trigger relatively high branch coverage. Here is the [corpus](https://drive.google.com/file/d/1abCTbhfWR8SwIASVFdH2bY0Cjfoh2GTD/view?usp=sharing) we used to test SQLite. We collect test cases from FuzzBench and SQLite repo and rename their names to numerical.

```
# record original files
$ python3 rec_ori_files.py

# For programs that take input from a file, use '@@'
# -a means dynamic timeout ratio
$ /path/to/viper/BranchForcer/afl-fuzz -t 1000+ -a 10 -i \
  /path/to/your/corpus -o output -- ./sqlite3_flip

# delete files generated by flipping
$ python3 rm_gen_files.py
```

You can find result in `./log/flip_result`  
You can use `grep -B 3 "New Syscalls:-" ./log/flip_result` to filter out potential syscall-guard branches/variables  

## Run VariableRator

### Compile sqlite3_rate
```
$ /path/to/viper/BranchForcer/afl-clang-fast-rate sqlite3.bc -o \
  sqlite3_rate -lpthread -lz -lm -ldl -lreadline
```

### Generate function map
```
$ objdump -d ./sqlite3_rate | grep ">:" > ./log/func_map
```

### Record
```
$ export FLIP_MODE=1 FLIP_BRANCH_ID=2512 (id of the branch you want to flip)
$ ./sqlite3_rate < corpus/1 (testcase to trigger the branch)
$ python3 lib_func_map_gen.py
```

### Backward Data-flow Analysis
```
# analyze the corruptibility of syscall-guard branch
# 0 represents the number of printed BasicBlocks, normally set to 0
$ ./rator sqlite3.bc 2512 0 ./dot/temp.dot (path to store data-flow graph)

# analyze the corruptibility of syscall arguments
./rator_arg sqlite3.bc 2512 execve 0 ./dot/temp.dot
```

The data-flow graph can be found in `./dot/`   
We also provide a python script to automatically assess corruptibility of all potential syscall-guard variables.
```
# assess syscall-guard variables
$ python3 auto_rator.py ./sqlite3.bc ./dot/temp.dot br -- ./sqlite3_rate

# assess arguments of triggered syscalls
$ python3 auto_rator.py ./sqlite3.bc ./dot/temp.dot arg -- ./sqlite3_rate
```